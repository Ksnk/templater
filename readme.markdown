# Шаблонизатор

В качестве исходного языка для реализации шаблонов выбираем http://jinja.pocoo.org/2/documentation/templates - Jinja2 - развитие языка Django-template.

## Документация

Ядро и описание языка шаблонов читаем на сайте <http://jinja.pocoo.org/2/documentation/templates>. Ниже будет описание имеющихся отличий.

Изменением, по сравнению с Jinja синтаксисом, будет возможность указывать ключи данных в \`\` кавычках (обратная одинарная). Такой синтаксис позволит добавить возможность использования ключей с пробелами и странными символами в параметрах шаблона. Если в ключе параметра используется символ \`, его нужно escape’ить(слешить) по обычным правилам языка С.

Изменением будет также дополнение тега `if`. Вместе с конструкцией `elif` можно будет указывать его синоним `elseif`, чтобы избежать ненужных ошибок у php программистов.

Все неизвестные системе идентификаторы автоматически считаются ключами передаваемых данных. Все неизвестные системе идентификаторы функций (за ними  стоит оператор вызова) считаются функциями вызова макрокоманд. Никакого дополнительного поиска смысла таких операторов не производится...

* Variables - Так как не предполагается использовать объекты в качестве данных для рендеринга, то способы указания выборки элемента и выборки из массива полностью эквивалентны.

* Filters - фильтры реализованы не полностью.

* Тests - тесты описаны не полностью. С точки зрения реализации фильтры от тестов отличаются только необходимостью приведения результата теста к логическому. внешний вид и правило описания фильтров и тестов одинаковы.

* Комментарии реализованы как блочные так и строчные.

* Whitespace control - реализовано.

* Escaping - тег raw реализован.

* Line statesment - не реализовано

* Наследование шаблонов реализовано. Функция super пока не реализована

* Именованные теги окончания блоков не реализованы.

* Block nesting and scoop - параметр scooped блока не реализован.

* List on control structures

* for - реализован без внутреннего if, но с  else и внутренним loop. Атрибут recursive отсутствует. Рекурсивные конструкции следует делать с помощью макросов.

* if реализован

* макросы реализованы без импорта, с позиционными и именованными параметрами. внутренние переменные не реализованы. Рекурсивный вызов макроса из другого макроса не требует дополнительных функций.

* Тег call не реализован

* Тег filter не реализован

* set реализован

* Extends реализован

* Include не реализован

* Import реализован пока в простом виде, без переопределения имен макросов

Список реализованных фильтров

* default
* escape , e 
* join
* length
* replace

тестов нет

Список функций

* lipsum

Теги, описанные в Extension никак не реализованы.

## Некоторые принципы работы

В результате работы транслятора получается некий php-класс. При рендеринге данных достаточно проинициировать этот класс и вызвать либо нужную функцию, либо “корневую” - ‘_’. Никаких дополнительных действий и включения в код файлов компилятора не нужно. Дополнительные фильтры и тесты, использующиеся в run-time рендеринге, описываются в классе tpl_base. 

Каждый блок шаблона транслируется в функцию класса. Весь шаблон транслируются в функцию ‘_’. Макрокоманды являются такими же функциями класса, однако в конструкторе класса заводится массив macro со всеми описанными в шаблоне макросами для последующего импорта. Импорт макросов заключается в инициализации импортируемого класса шаблона и слиянии собственного массива macro с импортируемым. "Переопределение" блоков достаточно корректно эмулируется простым наследованием классов. При этом отсутствует возможность эффективно узнать структуру предка класса и наличие импортируемых макросов. Таким образом, вставка макроса выглядит так

    if(!empty($this->macros[‘MACRONAME’])
        call_user_func($this->macros[‘MACRONAME’],PAR1,PAR2..)

Импорт макросов выглядит так

    function __construct (){
        // import ‘macros.tpl’
        require_once ‘macros.tpl.php’;
        $import= new macros();
        // конструкция import ‘macros.tpl’
        $this->macros=array_merge($this->macros,$import->macros);
        // конструкция from ‘macros.tpl’ import ‘yyy’ as’ ‘xxx’
        $this->macros[‘xxx’]=$import[‘yyy’]
    }

## API

унарные операции вводятся оператором newOp1
`->newOp1('not','!(%s)','BB')`

Первый параметр  - имя операции, второй printf-шаблон для генерации кода, третий - указания по преобразованию типов. Первая литера - преобразование к логическому типу, вторая литера - преобразование операнда к логическому типу перед вставкой в шаблон. Бинарные операции вводятся оператором newOp2
`->newOp2('== != > >= < <=',2,null,'B**')`

Сокращенный способ описания операторов, каждый из них будет вставлен в код по стандартному шаблону (%s) ОПЕРАЦИЯ (%s) , где ОПЕРАЦИЯ заменяется на описываемую операцию. изображения операций через пробел позволяет описывать несколько операций с одним приоритетом. Второй параметр - приоритет операции. Существенен только для бинарных операций. Третий параметр null - используется стандартный printf-шалон. Третий параметр - преобразование типов при генерации шаблона.

`->newOp2('and',3,'(%s) && (%s)','BBB')`
`->newOp2('|',11,array($this,'function_filter'))`

Полный способ описания операции. первый параметр - имя операции, второй - приоритет операции ,  третьим параметром может быть printf-шаблон или callback функции, выдающей представление функции.

`->newOpR('loop',array($this,'operand_loop'))`

- особый оператор `loop`. В зависимости от  применяемых к loop атрибутов  получается та или иная порождаемая конструкция. Вид и смысл конструкции определяется callback'ом.

новые функции, фильтры и тесты добавляются одинаковым образом. 
* В конструктор базового класса компилятора нужно вставить определение функции (для примера - функция escape) в виде:

`->newFunc('e','htmlspecialchars(%s)','SS')`
`->newFunc('escape','htmlspecialchars(%s)','SS')`

* Первый параметр - имя функции. второй параметр - шаблон для printf’а с одним параметром. Все переданные функции параметры укладываются в эту строку через запятую. Тут описываются две функции- синонима. Таким образом можно описывать конструкции, непосредственно преобразуемые в php-код. при изготовлении конструкта результат будет иметь строковый вид (первая литера третьего параметра) и будет произведено преобразование типов операндов к строковому виду (второй и следующие литеры)

При трансляции конструкции `{{user.username|e}}` получится `htmlspecialchars((isset($user['username'])?$user['username']:""))`

Функция lipsum
`->newFunc('lipsum','$this->func_lipsum(%s)')`
При генерации функции lipsum предполагается вызов функции func_lipsum из базового шаблона tpl_base.

    /**
     * функция lipsum
     */
    function func_lipsum($n=5, $html=True, $min=20, $max=100){
      $result='';
    ...
      return $result;
    }

      
Функция replace     
`->newFunc('replace',array($this,'function_replace'))`
Второй параметр - callback, который должен выдать представление функции в получившемся файле. Если нужно определить несколько синонимов функции - достаточно поменять имя функции. 
Callback может выглядеть так

      /**
       * фильтр - replace
       * @param operand $op1 - TYPE_ID - имя функции
       * @param operand $op2 - TYPE_LIST - параметры функции
       */
      function function_replace($op1,$op2){
        $op1->val= 'str_replace('.$this->to('S',$op2->value['keys'][1])->val
          .','.$this->to('S',$op2->value['keys'][2])->val
          .','.$this->to('S',$op2->value['keys'][0])->val
        .')';
        $op1->type="TYPE_OPERAND";
        return $op1;
      }

Выбор callback’а вместо явного представления в виде printf-шаблона сделан из за другого порядка следования операторов str_replace’а. Для пояснения  производимых действий

* функция получает 2 параметра - первый - оператор, содержащий имя функции, как правило - operand(val:’replace’,type:’TYPE_ID’) - имя функции, второй операнд содержит параметры, переданные при вызове функции.
*  функция to  преобразует операнд к нужному виду

## Типы данных и их скрытый смысл

При парсинге текста шаблона текст разбивается на лексемы с определенным типом. В процессе трансляции некоторые лексемы меняют свой тип.

* TYPE_STRING - содержимое строки, изначально заключенное в двойные кавычки
* TYPE_STRING1 - содержимое строки, изначально заключенное в одинарные кавычки

* TYPE_STRING2 - содержимое строки, изначально заключенное в обратные кавычки
* TYPE_ID - изображение идентификатора

* TYPE_OPERATION - изображение предварительно зарегистрированных функций и операций (регистрируются операторами newOp1, newOp2)
* TYPE_COMMA - нераспознанные символы

остальные типы появляются при дальнейшем анализе текста.

* TYPE_OBJECT - внутренний тип операнда, который позволяет выполнять вызов и получение атрибута от одного и того же идентификатора.

* TYPE_LIST - комплект операндов. Получается при анализе изображения массива, вызовов функций и описаний макросов. Содержит 2 внутренних массива операндов, именованных и позиционных. Их смысл меняется в зависимости от конструкции, которую анализировали.

* TYPE_OPERAND - конструкция, выдающая строковое значение. Может использоваться в качестве операнда конкатенации, а также в качестве  операнда php операторов. пример: ‘2’ (строковое изображение числа 2 с одинарными кавычками).

* TYPE_SENTENSE - готовые для вклеивания  в текст функции, через точку с запятой, операторы. Пример $x=2

## Шаблонизатор разбит на части

* компилятор
* внутренние шаблоны компилятора
* оттранслированные внутренние шаблоны компилятора

* система рендеринга
* 'боевые' шаблоны
* оттранслированные 'боевые' шаблоны

* внутренние шаблоны системы рендеринга (наследуются от внутренних шаблонов компилятора)

Для поставки достаточно системы рендеринга и оттранслированных 'боевые' шаблоны

Для возможности перетрансляции шаблонов на месте достаточно добавить
компилятор, 'основные' шаблоны и оттранслированные внутренние шаблоны компилятора

## Структура файлов дистрибутива

      -!            readme.txt - файл с описанием
       !-lib        каталог с файлами, необходимыми для компиляции шаблонов
       !-render     откомпилированные "внутренние" шаблоны. Их необходимо
       !            поместить в каталог templates проекта.
       !-samples    каталог с примерами
         !- templates    каталог с примерами шаблонов.
   
## Использование

Должна быть определена константа

* TEMPLATE_PATH - расположение шаблонов и откомпилированных шаблонов.

В каталоге samples имеется пример простой функции рендеринга откомпилированных шаблонов.
 `render.php`


